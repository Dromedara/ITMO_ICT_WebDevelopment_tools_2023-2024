{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0445 \u0440\u0430\u0431\u043e\u0442 \u041f\u0430\u0432\u043b\u0438\u0448\u0438\u043d\u0430 \u0418\u0440\u0438\u043d\u0430, \u041a33391","title":"Home"},{"location":"#_1","text":"","title":"\u0414\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u044f \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0445 \u0440\u0430\u0431\u043e\u0442"},{"location":"#33391","text":"","title":"\u041f\u0430\u0432\u043b\u0438\u0448\u0438\u043d\u0430 \u0418\u0440\u0438\u043d\u0430, \u041a33391"},{"location":"lab1_main/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f 1 \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 project/ \u2502 \u251c\u2500\u2500 db/ \u2502 \u2514\u2500\u2500 connection.py \u2502 \u251c\u2500\u2500 endpoints/ \u2502 \u251c\u2500\u2500 case_endpoints.py \u2502 \u251c\u2500\u2500 subcase_endpoint.py \u2502 \u251c\u2500\u2500 message_endpoint.py \u2502 \u251c\u2500\u2500 doing_endpoint.py \u2502 \u2514\u2500\u2500 user_endpoints.py \u2502 \u2514\u2500\u2500 main.py \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u044b API Cases \u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/cases \u0422\u0435\u0433: cases \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: case_router Subcases \u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/subcases \u0422\u0435\u0433: subcases \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: subcase_router Messages \u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/messages \u0422\u0435\u0433: messages \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: message_router Doings \u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/doing \u0422\u0435\u0433: doings \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: doing_router Users \u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api \u0422\u0435\u0433: users \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: user_router main.py \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0444\u0430\u0439\u043b \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u0442 \u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435. \u0418\u043c\u043f\u043e\u0440\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u0439 from fastapi import FastAPI import uvicorn from db.connection import init_db from endpoints.case_endpoints import case_router from endpoints.subcase_endpoint import subcase_router from endpoints.message_endpoint import message_router from endpoints.doing_endpoint import doing_router from endpoints.user_endpoints import user_router \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f app = FastAPI() \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440\u043e\u0432 app.include_router(case_router, prefix=\"/api/cases\", tags=[\"cases\"]) app.include_router(subcase_router, prefix=\"/api/subcases\", tags=[\"subcases\"]) app.include_router(message_router, prefix=\"/api/messages\", tags=[\"messages\"]) app.include_router(doing_router, prefix=\"/api/doing\", tags=[\"doings\"]) app.include_router(user_router, prefix=\"/api\", tags=[\"users\"]) \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 @app.on_event(\"startup\") def on_startup(): init_db() \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True) connetion.py \u0424\u0430\u0439\u043b, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0438\u0439 \u0437\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0431\u0430\u0437\u043e\u0439 \u0434\u0430\u043d\u043d\u044b\u0445 \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0435\u0439 from sqlmodel import SQLModel, Session, create_engine import os from dotenv import load_dotenv \u041f\u043e\u0434\u0433\u0440\u0443\u0437\u043a\u0430 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0441\u0440\u0435\u0434\u044b \u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u0430\u043d\u0430\u043b\u0430 \u0441\u0432\u044f\u0437\u0438 \u0441 \u0411\u0414 load_dotenv() db_url = os.getenv('DB_ADMIN') engine = create_engine(db_url, echo=True) \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435/\u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u0411\u0414 def init_db(): SQLModel.metadata.create_all(engine) \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 \u043e\u0431\u043c\u0435\u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u043c\u0438 def get_session(): with Session(engine) as session: yield session models.py \u0424\u0430\u0439\u043b, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0438\u0439 \u0437\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445. \u0418\u043c\u043f\u043e\u0440\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u0439 import datetime from pydantic import BaseModel from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship Message class ReadMessageUpdate(SQLModel): seemed: bool class MessageDefault(SQLModel): message: str seemed: bool doing_id: Optional[int] = Field(default=None, foreign_key=\"doing.id\") class MessagesSubmodels(MessageDefault): doing: Optional[\"Doing\"] = None class Message(MessageDefault, table=True): id: int = Field(default=None, primary_key=True) doing: Optional[\"Doing\"] = Relationship(back_populates=\"messages\") Task class DoingDefault(SQLModel): case_id: Optional[int] = Field( default=None, foreign_key=\"case.id\" ) user_id: Optional[int] = Field( default=None, foreign_key=\"user.id\" ) class DoingSubmodels(DoingDefault): time_spent: datetime.timedelta = None cases: Optional[\"Case\"] = None users: Optional[\"User\"] = None messages: Optional[List[\"Message\"]] = None class Doing(DoingDefault, table=True): id: int = Field(default=None, primary_key=True) time_spent: datetime.timedelta = datetime.timedelta(seconds=0) cases: Optional[\"Case\"] = Relationship(back_populates=\"doings\") users: Optional[\"User\"] = Relationship(back_populates=\"doings\") messages: Optional[List[\"Message\"]] = Relationship(back_populates=\"doing\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) class ManyToManyUpdate(BaseModel): time_spent: datetime.timedelta = datetime.timedelta(seconds=0) Subcase ```python Subcase class SubcaseDefault (SQLModel): what_to_do: str comment: str deadline: datetime.datetime case_id: Optional[int] = Field(default=None, foreign_key=\"case.id\") class SubcaseSubmodels(SubcaseDefault): case: Optional[\"Case\"] = None class Subcase(SubcaseDefault, table=True): id: int = Field(default=None, primary_key=True) case: Optional[\"Case\"] = Relationship(back_populates=\"subcases\") ### Case ```python class Priority(Enum): super_high = \"super_high\" high = \"high\" normal = \"normal\" low = \"low\" super_low = \"super_low\" class CaseDefault(SQLModel): name: str description: str priority: Priority class CaseSubmodels(CaseDefault): subcases: Optional[List[\"Subcase\"]] = None users: Optional[List[\"User\"]] = None class Case(CaseDefault, table=True): id: int = Field(default=None, primary_key=True) subcases: Optional[List[\"Subcase\"]] = Relationship(back_populates=\"case\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) users: Optional[List[\"User\"]] = Relationship( back_populates=\"cases\", link_model=Doing ) doings: Optional[List[\"Doing\"]] = Relationship(back_populates=\"cases\") User class UserDefault(SQLModel): username: str password: str class UserSubmodels(UserDefault): cases: Optional[List[\"Case\"]] = None doings: Optional[List[\"Doing\"]] = None class User(UserDefault, table=True): id: int = Field(default=None, primary_key=True) cases: Optional[List[\"Case\"]] = Relationship( back_populates=\"users\", link_model=Doing ) doings: Optional[List[\"Doing\"]] = Relationship(back_populates=\"users\") class ChangePassword(SQLModel): old_password: str new_password: str CRUD Case endpoints \u0420\u043e\u0443\u0442\u0435\u0440 \u043a\u0435\u0439\u0441\u043e\u0432 case_router = APIRouter() \u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 @case_router.post(\"/create\", status_code=status.HTTP_201_CREATED) def case_create(case: CaseDefault, session=Depends(get_session)) \\ -> Case: case = Case.model_validate(case) session.add(case) session.commit() session.refresh(case) return case @case_router.get(\"/list\", status_code=status.HTTP_200_OK) def cases_list(session=Depends(get_session)) -> list[Case]: return session.query(Case).all() @case_router.get(\"/{case_id}\", status_code=status.HTTP_200_OK, response_model=CaseSubmodels) def case_get(case_id: int, session=Depends(get_session)) -> Case: obj = session.get(Case, case_id) if obj is None: raise HTTPException(status_code=404, detail=\"subcase not found\") return obj @case_router.patch(\"/update-{case_id}\", status_code=status.HTTP_202_ACCEPTED) def case_update(case_id: int, case: CaseDefault, session=Depends(get_session)) -> Case: db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"Case not found\") case_data = case.model_dump(exclude_unset=True) for key, value in case_data.items(): setattr(db_case, key, value) session.add(db_case) session.commit() session.refresh(db_case) return db_case @case_router.delete(\"/delete{case_id}\", status_code=status.HTTP_204_NO_CONTENT) def case_delete(case_id: int, session=Depends(get_session)): case = session.get(Case, case_id) if not case: raise HTTPException(status_code=404, detail=\"case not found\") session.delete(case) session.commit() return {\"ok\": True} Doing endpoints \u0420\u043e\u0443\u0442\u0435\u0440 \u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u0435\u0439\u0441\u043e\u0432 doing_router = APIRouter() \u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 @doing_router.post(\"/set-user{user_id}-to-case{case_id}\", status_code=status.HTTP_201_CREATED) def user_case_update(user_id: int, case_id: int, session=Depends(get_session)) ->\\ Doing: db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") doing = Doing(user_id=user_id, case_id=case_id) session.add(doing) session.commit() session.refresh(doing) return doing @doing_router.get(\"/get-user{user_id}-to-case{case_id}\", status_code=status.HTTP_200_OK, response_model=DoingSubmodels) def user_case_get(user_id: int, case_id: int, session=Depends(get_session)) -> Doing: db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") qs = session.exec(select(Doing).where(Doing.case_id == case_id).where(Doing.user_id == user_id)) doing = qs.first() if not doing: raise HTTPException(status_code=404, detail=\"User was not associated with this case.\") return doing[0] @doing_router.delete(\"/remove-user{user_id}-from-case{case_id}\", status_code=status.HTTP_204_NO_CONTENT) def user_case_delete(user_id: int, case_id: int, session=Depends(get_session)): db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") qs = session.exec(select(Doing).where(Doing.case_id == case_id).where(Doing.user_id == user_id)) doing = qs.first() if not doing: raise HTTPException(status_code=404, detail=\"User was not associated with this case.\") session.delete(doing[0]) session.commit() return {\"ok\": True} @doing_router.patch(\"/update-user{user_id}-from-case{case_id}\", status_code=status.HTTP_202_ACCEPTED, response_model=DoingSubmodels) def user_case_update(user_id: int, case_id: int, doing_data: ManyToManyUpdate, session=Depends(get_session)) -> Doing: db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") qs = session.exec(select(Doing).where(Doing.case_id == case_id).where(Doing.user_id == user_id)) doing = qs.first() if not doing: raise HTTPException(status_code=404, detail=\"User was not associated with this case.\") db_doing = doing[0] doing_data = doing_data.model_dump(exclude_unset=True) for key, value in doing_data.items(): setattr(db_doing, key, value) session.add(db_doing) session.commit() session.refresh(db_doing) return db_doing Subcase endpoints \u0420\u043e\u0443\u0442\u0435\u0440 \u0441\u0443\u0431-\u043a\u0435\u0439\u0441\u043e\u0432 subcase_router = APIRouter() \u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 @subcase_router.post(\"/create\", status_code=status.HTTP_201_CREATED) def subcase_create(subcase: SubcaseDefault, session=Depends(get_session)) \\ -> Subcase: subcase = Subcase.model_validate(subcase) session.add(subcase) session.commit() session.refresh(subcase) return subcase @subcase_router.get(\"/list-in/{case_id}\", status_code=status.HTTP_200_OK) def subcases_list(case_id: int, session=Depends(get_session)) -> list[Subcase]: return session.query(Subcase).filter(Subcase.case_id == case_id).all() @subcase_router.get(\"/{subcase_id}\", status_code=status.HTTP_200_OK, response_model=SubcaseSubmodels) def subcase_get(subcase_id: int, session=Depends(get_session)) -> Subcase: obj = session.get(Subcase, subcase_id) if obj is None: raise HTTPException(status_code=404, detail=\"subcase not found\") return obj @subcase_router.patch(\"/update-{subcase_id}\", status_code=status.HTTP_202_ACCEPTED) def subcase_update(subcase_id: int, subcase: SubcaseDefault, session=Depends(get_session)) -> Subcase: db_subcase = session.get(Subcase, subcase_id) if not db_subcase: raise HTTPException(status_code=404, detail=\"subcase not found\") subcase_data = subcase.model_dump(exclude_unset=True) for key, value in subcase_data.items(): setattr(db_subcase, key, value) session.add(db_subcase) session.commit() session.refresh(db_subcase) return db_subcase @subcase_router.delete(\"/delete{subcase_id}\", status_code=status.HTTP_204_NO_CONTENT) def subcase_delete(subcase_id: int, session=Depends(get_session)): subcase = session.get(Subcase, subcase_id) if not subcase: raise HTTPException(status_code=404, detail=\"subcase not found\") session.delete(subcase) session.commit() return {\"ok\": True} Message endpoints \u0420\u043e\u0443\u0442\u0435\u0440 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 message_router = APIRouter() \u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 @message_router.post(\"/create\", status_code=status.HTTP_201_CREATED) def message_create(message: MessageDefault, session=Depends(get_session)) \\ -> Message: message = Message.model_validate(message) session.add(message) session.commit() session.refresh(message) return message @message_router.get(\"/list-in/{doing_id}\", status_code=status.HTTP_200_OK) def messages_list(doing_id: int, session=Depends(get_session)) -> list[Message]: return session.query(Message).filter(Message.doing_id == doing_id).all() @message_router.get(\"/{message_id}\", status_code=status.HTTP_200_OK, response_model=MessagesSubmodels) def message_get(message_id: int, session=Depends(get_session)) -> Message: obj = session.get(Message, message_id) if obj is None: raise HTTPException(status_code=404, detail=\"message not found\") return obj @message_router.patch(\"/update-{message_id}\", status_code=status.HTTP_202_ACCEPTED) def message_update(message_id: int, message: ReadMessageUpdate, session=Depends(get_session)) -> Message: db_message = session.get(Message, message_id) if not db_message: raise HTTPException(status_code=404, detail=\"message not found\") message_data = message.model_dump(exclude_unset=True) for key, value in message_data.items(): setattr(db_message, key, value) session.add(db_message) session.commit() session.refresh(db_message) return db_message @message_router.delete(\"/delete{message_id}\", status_code=status.HTTP_204_NO_CONTENT) def message_delete(message_id: int, session=Depends(get_session)): message = session.get(Message, message_id) if not message: raise HTTPException(status_code=404, detail=\"message not found\") session.delete(message) session.commit() return {\"ok\": True} User endpoints \u041f\u043e\u0434\u0433\u0440\u0443\u0437\u043a\u0430 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0441\u0440\u0435\u0434\u044b, \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445, \u0440\u043e\u0443\u0442\u0435\u0440\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 dotenv.load_dotenv() security = HTTPBearer() pwd_context = CryptContext(schemes=['bcrypt']) secret = os.environ.get(\"SECRET\") algorythm = os.environ.get(\"ALGORYTHM\") user_router = APIRouter() \u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0410 \u0442\u0430\u043a \u0436\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0430\u0445\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u043e\u043a\u0435\u043d\u0430, \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f @user_router.get(\"/users-list\") def users_list(session=Depends(get_session)) -> list[User]: return session.query(User).all() def get_password_hash(password): return pwd_context.hash(password) @user_router.post('/registration', status_code=201) def register(user: UserDefault, session=Depends(get_session)): users = session.exec(select(User)).all() if any(x.username == user.username for x in users): raise HTTPException(status_code=400, detail='Username is taken') hashed_pwd = get_password_hash(user.password) user = User(username=user.username, password=hashed_pwd) session.add(user) session.commit() return {\"status\": 201, \"message\": \"Created\"} def verify_password(pwd, hashed_pwd): return pwd_context.verify(pwd, hashed_pwd) def encode_token(user_id): payload = { 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=8), 'iat': datetime.datetime.utcnow(), 'sub': user_id } return jwt.encode(payload, secret, algorithm=algorythm) @user_router.post('/login') def login(user: UserDefault, session=Depends(get_session)): user_found = session.exec(select(User).where(User.username == user.username)).first() if not user_found: raise HTTPException(status_code=401, detail='Invalid username and/or password') verified = verify_password(user.password, user_found.password) if not verified: raise HTTPException(status_code=401, detail='Invalid username and/or password') token = encode_token(user_found.username) return {'token': token} def decode_token(token): try: payload = jwt.decode(token, secret, algorithms=[algorythm]) return payload['sub'] except Exception: raise HTTPException(status_code=401, detail='Token error') def get_current_user(auth: HTTPAuthorizationCredentials = Security(security), session=Depends(get_session)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail='Could not validate credentials' ) username = decode_token(auth.credentials) if username is None: raise credentials_exception user = session.exec(select(User).where(User.username == username)).first() if user is None: raise credentials_exception return user @user_router.get('/users/me') def user_me(user: User = Depends(get_current_user)) -> UserSubmodels: return user @user_router.patch(\"/users/me/reset-password\") def user_pwd(user_pwd: ChangePassword, session=Depends(get_session), current=Depends(get_current_user)): found_user = session.get(User, current.id) if not found_user: raise HTTPException(status_code=404, detail=\"User not found\") verified = verify_password(user_pwd.old_password, found_user.password) if not verified: raise HTTPException(status_code=400, detail=\"Invalid old password\") hashed_pwd = get_password_hash(user_pwd.new_password) found_user.password = hashed_pwd session.add(found_user) session.commit() session.refresh(found_user) return {\"status\": 200, \"message\": \"password changed successfully\"}","title":"Lab1"},{"location":"lab1_main/#1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f 1"},{"location":"lab1_main/#_1","text":"project/ \u2502 \u251c\u2500\u2500 db/ \u2502 \u2514\u2500\u2500 connection.py \u2502 \u251c\u2500\u2500 endpoints/ \u2502 \u251c\u2500\u2500 case_endpoints.py \u2502 \u251c\u2500\u2500 subcase_endpoint.py \u2502 \u251c\u2500\u2500 message_endpoint.py \u2502 \u251c\u2500\u2500 doing_endpoint.py \u2502 \u2514\u2500\u2500 user_endpoints.py \u2502 \u2514\u2500\u2500 main.py","title":"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430"},{"location":"lab1_main/#api","text":"","title":"\u041c\u0430\u0440\u0448\u0440\u0443\u0442\u044b API"},{"location":"lab1_main/#cases","text":"\u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/cases \u0422\u0435\u0433: cases \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: case_router","title":"Cases"},{"location":"lab1_main/#subcases","text":"\u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/subcases \u0422\u0435\u0433: subcases \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: subcase_router","title":"Subcases"},{"location":"lab1_main/#messages","text":"\u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/messages \u0422\u0435\u0433: messages \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: message_router","title":"Messages"},{"location":"lab1_main/#doings","text":"\u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api/doing \u0422\u0435\u0433: doings \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: doing_router","title":"Doings"},{"location":"lab1_main/#users","text":"\u041f\u0440\u0435\u0444\u0438\u043a\u0441: /api \u0422\u0435\u0433: users \u041c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440: user_router","title":"Users"},{"location":"lab1_main/#mainpy","text":"\u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0444\u0430\u0439\u043b \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u0442 \u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 FastAPI \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435.","title":"main.py"},{"location":"lab1_main/#_2","text":"from fastapi import FastAPI import uvicorn from db.connection import init_db from endpoints.case_endpoints import case_router from endpoints.subcase_endpoint import subcase_router from endpoints.message_endpoint import message_router from endpoints.doing_endpoint import doing_router from endpoints.user_endpoints import user_router","title":"\u0418\u043c\u043f\u043e\u0440\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u0439"},{"location":"lab1_main/#_3","text":"app = FastAPI()","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"lab1_main/#_4","text":"app.include_router(case_router, prefix=\"/api/cases\", tags=[\"cases\"]) app.include_router(subcase_router, prefix=\"/api/subcases\", tags=[\"subcases\"]) app.include_router(message_router, prefix=\"/api/messages\", tags=[\"messages\"]) app.include_router(doing_router, prefix=\"/api/doing\", tags=[\"doings\"]) app.include_router(user_router, prefix=\"/api\", tags=[\"users\"])","title":"\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0438\u0437\u0430\u0442\u043e\u0440\u043e\u0432"},{"location":"lab1_main/#_5","text":"@app.on_event(\"startup\") def on_startup(): init_db()","title":"\u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445"},{"location":"lab1_main/#_6","text":"if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"\u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f"},{"location":"lab1_main/#connetionpy","text":"\u0424\u0430\u0439\u043b, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0438\u0439 \u0437\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0431\u0430\u0437\u043e\u0439 \u0434\u0430\u043d\u043d\u044b\u0445","title":"connetion.py"},{"location":"lab1_main/#_7","text":"from sqlmodel import SQLModel, Session, create_engine import os from dotenv import load_dotenv","title":"\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0435\u0439"},{"location":"lab1_main/#_8","text":"load_dotenv() db_url = os.getenv('DB_ADMIN') engine = create_engine(db_url, echo=True)","title":"\u041f\u043e\u0434\u0433\u0440\u0443\u0437\u043a\u0430 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0441\u0440\u0435\u0434\u044b \u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043a\u0430\u043d\u0430\u043b\u0430 \u0441\u0432\u044f\u0437\u0438 \u0441 \u0411\u0414"},{"location":"lab1_main/#_9","text":"def init_db(): SQLModel.metadata.create_all(engine)","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435/\u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u0411\u0414"},{"location":"lab1_main/#_10","text":"def get_session(): with Session(engine) as session: yield session","title":"\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 \u043e\u0431\u043c\u0435\u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u043c\u0438"},{"location":"lab1_main/#modelspy","text":"\u0424\u0430\u0439\u043b, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0438\u0439 \u0437\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044e \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445.","title":"models.py"},{"location":"lab1_main/#_11","text":"import datetime from pydantic import BaseModel from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship","title":"\u0418\u043c\u043f\u043e\u0440\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u0439"},{"location":"lab1_main/#message","text":"class ReadMessageUpdate(SQLModel): seemed: bool class MessageDefault(SQLModel): message: str seemed: bool doing_id: Optional[int] = Field(default=None, foreign_key=\"doing.id\") class MessagesSubmodels(MessageDefault): doing: Optional[\"Doing\"] = None class Message(MessageDefault, table=True): id: int = Field(default=None, primary_key=True) doing: Optional[\"Doing\"] = Relationship(back_populates=\"messages\")","title":"Message"},{"location":"lab1_main/#task","text":"class DoingDefault(SQLModel): case_id: Optional[int] = Field( default=None, foreign_key=\"case.id\" ) user_id: Optional[int] = Field( default=None, foreign_key=\"user.id\" ) class DoingSubmodels(DoingDefault): time_spent: datetime.timedelta = None cases: Optional[\"Case\"] = None users: Optional[\"User\"] = None messages: Optional[List[\"Message\"]] = None class Doing(DoingDefault, table=True): id: int = Field(default=None, primary_key=True) time_spent: datetime.timedelta = datetime.timedelta(seconds=0) cases: Optional[\"Case\"] = Relationship(back_populates=\"doings\") users: Optional[\"User\"] = Relationship(back_populates=\"doings\") messages: Optional[List[\"Message\"]] = Relationship(back_populates=\"doing\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) class ManyToManyUpdate(BaseModel): time_spent: datetime.timedelta = datetime.timedelta(seconds=0)","title":"Task"},{"location":"lab1_main/#subcase","text":"```python Subcase class SubcaseDefault (SQLModel): what_to_do: str comment: str deadline: datetime.datetime case_id: Optional[int] = Field(default=None, foreign_key=\"case.id\") class SubcaseSubmodels(SubcaseDefault): case: Optional[\"Case\"] = None class Subcase(SubcaseDefault, table=True): id: int = Field(default=None, primary_key=True) case: Optional[\"Case\"] = Relationship(back_populates=\"subcases\") ### Case ```python class Priority(Enum): super_high = \"super_high\" high = \"high\" normal = \"normal\" low = \"low\" super_low = \"super_low\" class CaseDefault(SQLModel): name: str description: str priority: Priority class CaseSubmodels(CaseDefault): subcases: Optional[List[\"Subcase\"]] = None users: Optional[List[\"User\"]] = None class Case(CaseDefault, table=True): id: int = Field(default=None, primary_key=True) subcases: Optional[List[\"Subcase\"]] = Relationship(back_populates=\"case\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) users: Optional[List[\"User\"]] = Relationship( back_populates=\"cases\", link_model=Doing ) doings: Optional[List[\"Doing\"]] = Relationship(back_populates=\"cases\")","title":"Subcase"},{"location":"lab1_main/#user","text":"class UserDefault(SQLModel): username: str password: str class UserSubmodels(UserDefault): cases: Optional[List[\"Case\"]] = None doings: Optional[List[\"Doing\"]] = None class User(UserDefault, table=True): id: int = Field(default=None, primary_key=True) cases: Optional[List[\"Case\"]] = Relationship( back_populates=\"users\", link_model=Doing ) doings: Optional[List[\"Doing\"]] = Relationship(back_populates=\"users\") class ChangePassword(SQLModel): old_password: str new_password: str","title":"User"},{"location":"lab1_main/#crud","text":"","title":"CRUD"},{"location":"lab1_main/#case-endpoints","text":"","title":"Case endpoints"},{"location":"lab1_main/#_12","text":"case_router = APIRouter()","title":"\u0420\u043e\u0443\u0442\u0435\u0440 \u043a\u0435\u0439\u0441\u043e\u0432"},{"location":"lab1_main/#_13","text":"@case_router.post(\"/create\", status_code=status.HTTP_201_CREATED) def case_create(case: CaseDefault, session=Depends(get_session)) \\ -> Case: case = Case.model_validate(case) session.add(case) session.commit() session.refresh(case) return case @case_router.get(\"/list\", status_code=status.HTTP_200_OK) def cases_list(session=Depends(get_session)) -> list[Case]: return session.query(Case).all() @case_router.get(\"/{case_id}\", status_code=status.HTTP_200_OK, response_model=CaseSubmodels) def case_get(case_id: int, session=Depends(get_session)) -> Case: obj = session.get(Case, case_id) if obj is None: raise HTTPException(status_code=404, detail=\"subcase not found\") return obj @case_router.patch(\"/update-{case_id}\", status_code=status.HTTP_202_ACCEPTED) def case_update(case_id: int, case: CaseDefault, session=Depends(get_session)) -> Case: db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"Case not found\") case_data = case.model_dump(exclude_unset=True) for key, value in case_data.items(): setattr(db_case, key, value) session.add(db_case) session.commit() session.refresh(db_case) return db_case @case_router.delete(\"/delete{case_id}\", status_code=status.HTTP_204_NO_CONTENT) def case_delete(case_id: int, session=Depends(get_session)): case = session.get(Case, case_id) if not case: raise HTTPException(status_code=404, detail=\"case not found\") session.delete(case) session.commit() return {\"ok\": True}","title":"\u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432"},{"location":"lab1_main/#doing-endpoints","text":"","title":"Doing endpoints"},{"location":"lab1_main/#_14","text":"doing_router = APIRouter()","title":"\u0420\u043e\u0443\u0442\u0435\u0440 \u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u0435\u0439\u0441\u043e\u0432"},{"location":"lab1_main/#_15","text":"@doing_router.post(\"/set-user{user_id}-to-case{case_id}\", status_code=status.HTTP_201_CREATED) def user_case_update(user_id: int, case_id: int, session=Depends(get_session)) ->\\ Doing: db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") doing = Doing(user_id=user_id, case_id=case_id) session.add(doing) session.commit() session.refresh(doing) return doing @doing_router.get(\"/get-user{user_id}-to-case{case_id}\", status_code=status.HTTP_200_OK, response_model=DoingSubmodels) def user_case_get(user_id: int, case_id: int, session=Depends(get_session)) -> Doing: db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") qs = session.exec(select(Doing).where(Doing.case_id == case_id).where(Doing.user_id == user_id)) doing = qs.first() if not doing: raise HTTPException(status_code=404, detail=\"User was not associated with this case.\") return doing[0] @doing_router.delete(\"/remove-user{user_id}-from-case{case_id}\", status_code=status.HTTP_204_NO_CONTENT) def user_case_delete(user_id: int, case_id: int, session=Depends(get_session)): db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") qs = session.exec(select(Doing).where(Doing.case_id == case_id).where(Doing.user_id == user_id)) doing = qs.first() if not doing: raise HTTPException(status_code=404, detail=\"User was not associated with this case.\") session.delete(doing[0]) session.commit() return {\"ok\": True} @doing_router.patch(\"/update-user{user_id}-from-case{case_id}\", status_code=status.HTTP_202_ACCEPTED, response_model=DoingSubmodels) def user_case_update(user_id: int, case_id: int, doing_data: ManyToManyUpdate, session=Depends(get_session)) -> Doing: db_user = session.get(User, user_id) if not db_user: raise HTTPException(status_code=404, detail=\"user not found\") db_case = session.get(Case, case_id) if not db_case: raise HTTPException(status_code=404, detail=\"case not found\") qs = session.exec(select(Doing).where(Doing.case_id == case_id).where(Doing.user_id == user_id)) doing = qs.first() if not doing: raise HTTPException(status_code=404, detail=\"User was not associated with this case.\") db_doing = doing[0] doing_data = doing_data.model_dump(exclude_unset=True) for key, value in doing_data.items(): setattr(db_doing, key, value) session.add(db_doing) session.commit() session.refresh(db_doing) return db_doing","title":"\u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432"},{"location":"lab1_main/#subcase-endpoints","text":"","title":"Subcase endpoints"},{"location":"lab1_main/#-","text":"subcase_router = APIRouter()","title":"\u0420\u043e\u0443\u0442\u0435\u0440 \u0441\u0443\u0431-\u043a\u0435\u0439\u0441\u043e\u0432"},{"location":"lab1_main/#_16","text":"@subcase_router.post(\"/create\", status_code=status.HTTP_201_CREATED) def subcase_create(subcase: SubcaseDefault, session=Depends(get_session)) \\ -> Subcase: subcase = Subcase.model_validate(subcase) session.add(subcase) session.commit() session.refresh(subcase) return subcase @subcase_router.get(\"/list-in/{case_id}\", status_code=status.HTTP_200_OK) def subcases_list(case_id: int, session=Depends(get_session)) -> list[Subcase]: return session.query(Subcase).filter(Subcase.case_id == case_id).all() @subcase_router.get(\"/{subcase_id}\", status_code=status.HTTP_200_OK, response_model=SubcaseSubmodels) def subcase_get(subcase_id: int, session=Depends(get_session)) -> Subcase: obj = session.get(Subcase, subcase_id) if obj is None: raise HTTPException(status_code=404, detail=\"subcase not found\") return obj @subcase_router.patch(\"/update-{subcase_id}\", status_code=status.HTTP_202_ACCEPTED) def subcase_update(subcase_id: int, subcase: SubcaseDefault, session=Depends(get_session)) -> Subcase: db_subcase = session.get(Subcase, subcase_id) if not db_subcase: raise HTTPException(status_code=404, detail=\"subcase not found\") subcase_data = subcase.model_dump(exclude_unset=True) for key, value in subcase_data.items(): setattr(db_subcase, key, value) session.add(db_subcase) session.commit() session.refresh(db_subcase) return db_subcase @subcase_router.delete(\"/delete{subcase_id}\", status_code=status.HTTP_204_NO_CONTENT) def subcase_delete(subcase_id: int, session=Depends(get_session)): subcase = session.get(Subcase, subcase_id) if not subcase: raise HTTPException(status_code=404, detail=\"subcase not found\") session.delete(subcase) session.commit() return {\"ok\": True}","title":"\u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432"},{"location":"lab1_main/#message-endpoints","text":"","title":"Message endpoints"},{"location":"lab1_main/#_17","text":"message_router = APIRouter()","title":"\u0420\u043e\u0443\u0442\u0435\u0440 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439"},{"location":"lab1_main/#_18","text":"@message_router.post(\"/create\", status_code=status.HTTP_201_CREATED) def message_create(message: MessageDefault, session=Depends(get_session)) \\ -> Message: message = Message.model_validate(message) session.add(message) session.commit() session.refresh(message) return message @message_router.get(\"/list-in/{doing_id}\", status_code=status.HTTP_200_OK) def messages_list(doing_id: int, session=Depends(get_session)) -> list[Message]: return session.query(Message).filter(Message.doing_id == doing_id).all() @message_router.get(\"/{message_id}\", status_code=status.HTTP_200_OK, response_model=MessagesSubmodels) def message_get(message_id: int, session=Depends(get_session)) -> Message: obj = session.get(Message, message_id) if obj is None: raise HTTPException(status_code=404, detail=\"message not found\") return obj @message_router.patch(\"/update-{message_id}\", status_code=status.HTTP_202_ACCEPTED) def message_update(message_id: int, message: ReadMessageUpdate, session=Depends(get_session)) -> Message: db_message = session.get(Message, message_id) if not db_message: raise HTTPException(status_code=404, detail=\"message not found\") message_data = message.model_dump(exclude_unset=True) for key, value in message_data.items(): setattr(db_message, key, value) session.add(db_message) session.commit() session.refresh(db_message) return db_message @message_router.delete(\"/delete{message_id}\", status_code=status.HTTP_204_NO_CONTENT) def message_delete(message_id: int, session=Depends(get_session)): message = session.get(Message, message_id) if not message: raise HTTPException(status_code=404, detail=\"message not found\") session.delete(message) session.commit() return {\"ok\": True}","title":"\u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432"},{"location":"lab1_main/#user-endpoints","text":"","title":"User endpoints"},{"location":"lab1_main/#_19","text":"dotenv.load_dotenv() security = HTTPBearer() pwd_context = CryptContext(schemes=['bcrypt']) secret = os.environ.get(\"SECRET\") algorythm = os.environ.get(\"ALGORYTHM\") user_router = APIRouter()","title":"\u041f\u043e\u0434\u0433\u0440\u0443\u0437\u043a\u0430 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0441\u0440\u0435\u0434\u044b, \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445, \u0440\u043e\u0443\u0442\u0435\u0440\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439"},{"location":"lab1_main/#_20","text":"\u0410 \u0442\u0430\u043a \u0436\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0430\u0445\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u0430\u0440\u043e\u043b\u044f, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0442\u043e\u043a\u0435\u043d\u0430, \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f @user_router.get(\"/users-list\") def users_list(session=Depends(get_session)) -> list[User]: return session.query(User).all() def get_password_hash(password): return pwd_context.hash(password) @user_router.post('/registration', status_code=201) def register(user: UserDefault, session=Depends(get_session)): users = session.exec(select(User)).all() if any(x.username == user.username for x in users): raise HTTPException(status_code=400, detail='Username is taken') hashed_pwd = get_password_hash(user.password) user = User(username=user.username, password=hashed_pwd) session.add(user) session.commit() return {\"status\": 201, \"message\": \"Created\"} def verify_password(pwd, hashed_pwd): return pwd_context.verify(pwd, hashed_pwd) def encode_token(user_id): payload = { 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=8), 'iat': datetime.datetime.utcnow(), 'sub': user_id } return jwt.encode(payload, secret, algorithm=algorythm) @user_router.post('/login') def login(user: UserDefault, session=Depends(get_session)): user_found = session.exec(select(User).where(User.username == user.username)).first() if not user_found: raise HTTPException(status_code=401, detail='Invalid username and/or password') verified = verify_password(user.password, user_found.password) if not verified: raise HTTPException(status_code=401, detail='Invalid username and/or password') token = encode_token(user_found.username) return {'token': token} def decode_token(token): try: payload = jwt.decode(token, secret, algorithms=[algorythm]) return payload['sub'] except Exception: raise HTTPException(status_code=401, detail='Token error') def get_current_user(auth: HTTPAuthorizationCredentials = Security(security), session=Depends(get_session)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail='Could not validate credentials' ) username = decode_token(auth.credentials) if username is None: raise credentials_exception user = session.exec(select(User).where(User.username == username)).first() if user is None: raise credentials_exception return user @user_router.get('/users/me') def user_me(user: User = Depends(get_current_user)) -> UserSubmodels: return user @user_router.patch(\"/users/me/reset-password\") def user_pwd(user_pwd: ChangePassword, session=Depends(get_session), current=Depends(get_current_user)): found_user = session.get(User, current.id) if not found_user: raise HTTPException(status_code=404, detail=\"User not found\") verified = verify_password(user_pwd.old_password, found_user.password) if not verified: raise HTTPException(status_code=400, detail=\"Invalid old password\") hashed_pwd = get_password_hash(user_pwd.new_password) found_user.password = hashed_pwd session.add(found_user) session.commit() session.refresh(found_user) return {\"status\": 200, \"message\": \"password changed successfully\"}","title":"\u042d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f, \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432"},{"location":"lab_2/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f 2 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 Thread import threading import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_threads = 4 total_sum = 0 n = 1000000 thread_list = [] result = [0] * total_threads step = n // total_threads for i in range(total_threads): start = i * step + 1 end = (i + 1) * step if i != total_threads - 1 else n thread = threading.Thread(target=calculate_partial_sum, args=(start, end, result, i)) thread_list.append(thread) thread.start() for thread in thread_list: thread.join() total_sum = sum(result) return total_sum start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Threading sum: {sum_result}, Time taken: {end_time - start_time} seconds\") Multiprocess import multiprocessing import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_processes = 4 total_sum = 0 n = 1000000 process_list = [] manager = multiprocessing.Manager() result = manager.list([0] * total_processes) step = n // total_processes for i in range(total_processes): start = i * step + 1 end = (i + 1) * step if i != total_processes - 1 else n process = multiprocessing.Process(target=calculate_partial_sum, args=(start, end, result, i)) process_list.append(process) process.start() for process in process_list: process.join() total_sum = sum(result) return total_sum if __name__ == '__main__': start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Multiprocessing sum: {sum_result}, Time taken: {end_time - start_time} seconds\") Async import asyncio import time async def calculate_partial_sum(start, end): return sum(range(start, end + 1)) async def calculate_sum(): total_tasks = 4 n = 1000000 step = n // total_tasks tasks = [] for i in range(total_tasks): start = i * step + 1 end = (i + 1) * step if i != total_tasks - 1 else n tasks.append(asyncio.create_task(calculate_partial_sum(start, end))) results = await asyncio.gather(*tasks) total_sum = sum(results) return total_sum start_time = time.time() sum_result = asyncio.run(calculate_sum()) end_time = time.time() print(f\"Async sum: {sum_result}, Time taken: {end_time - start_time} seconds\") \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 Async import os import aiohttp import asyncio import asyncpg from bs4 import BeautifulSoup import time from ex_2.urls import urls from dotenv import load_dotenv load_dotenv() async def save_to_db(data): conn = await asyncpg.connect(os.getenv(\"DB_URL\")) try: await conn.execute( \"INSERT INTO parce (url, title, process_type) VALUES ($1, $2, $3)\", data['url'], data['title'], 'async' ) finally: await conn.close() async def parse_and_save(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') title = soup.find('title').text await save_to_db({'url': url, 'title': title}) async def main(urls): tasks = [] for url in urls: task = asyncio.create_task(parse_and_save(url)) tasks.append(task) await asyncio.gather(*tasks) if __name__ == \"__main__\": start_time = time.time() asyncio.run(main(urls)) end_time = time.time() execution_time = end_time - start_time with open('../times.txt', 'a') as f: f.write(f\"Async: {execution_time}\\n\") Thread from threading import Thread import requests from bs4 import BeautifulSoup import time from ex_2.urls import urls from ex_2.db import save_to_database from dotenv import load_dotenv load_dotenv() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title, 'threading') def main(urls): threads = [] for url in urls: thread = Thread(target=parse_and_save, args=(url,)) threads.append(thread) thread.start() for thread in threads: thread.join() if __name__ == \"__main__\": start_time = time.time() main(urls) end_time = time.time() execution_time = end_time - start_time with open('../times.txt', 'a') as f: f.write(f\"Tread: {execution_time}\\n\") Multiprocess from multiprocessing import Pool import requests from bs4 import BeautifulSoup import time from ex_2.urls import urls from ex_2.db import save_to_database from dotenv import load_dotenv load_dotenv() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title, 'mltprcs') def main(urls): num_process = len(urls) if len(urls) < 4 else 4 pool = Pool(processes=num_process) pool.map(parse_and_save, urls) if __name__ == \"__main__\": start_time = time.time() main(urls) end_time = time.time() execution_time = end_time - start_time with open('../times.txt', 'a') as f: f.write(f\"Multiprocess: {execution_time}\\n\") Database save (for threading and myltiprocess) import psycopg2 import os from dotenv import load_dotenv load_dotenv() def save_to_database(url, title, method): conn = psycopg2.connect(os.getenv(\"DB_URL\")) curs = conn.cursor() curs.execute(\"INSERT INTO parce (url, title, process_type) VALUES (%s, %s, %s)\", (url, title, method)) conn.commit() curs.close() conn.close() \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b | Solution | Time (seconds) | |---------------|--------------------| | Async | 1.2993099689483643 | | Multiprocess | 1.6727426052093506 | | Threading | 1.244816780090332 |","title":"Lab2"},{"location":"lab_2/#2","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f 2"},{"location":"lab_2/#1","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"lab_2/#thread","text":"import threading import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_threads = 4 total_sum = 0 n = 1000000 thread_list = [] result = [0] * total_threads step = n // total_threads for i in range(total_threads): start = i * step + 1 end = (i + 1) * step if i != total_threads - 1 else n thread = threading.Thread(target=calculate_partial_sum, args=(start, end, result, i)) thread_list.append(thread) thread.start() for thread in thread_list: thread.join() total_sum = sum(result) return total_sum start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Threading sum: {sum_result}, Time taken: {end_time - start_time} seconds\")","title":"Thread"},{"location":"lab_2/#multiprocess","text":"import multiprocessing import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_processes = 4 total_sum = 0 n = 1000000 process_list = [] manager = multiprocessing.Manager() result = manager.list([0] * total_processes) step = n // total_processes for i in range(total_processes): start = i * step + 1 end = (i + 1) * step if i != total_processes - 1 else n process = multiprocessing.Process(target=calculate_partial_sum, args=(start, end, result, i)) process_list.append(process) process.start() for process in process_list: process.join() total_sum = sum(result) return total_sum if __name__ == '__main__': start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Multiprocessing sum: {sum_result}, Time taken: {end_time - start_time} seconds\")","title":"Multiprocess"},{"location":"lab_2/#async","text":"import asyncio import time async def calculate_partial_sum(start, end): return sum(range(start, end + 1)) async def calculate_sum(): total_tasks = 4 n = 1000000 step = n // total_tasks tasks = [] for i in range(total_tasks): start = i * step + 1 end = (i + 1) * step if i != total_tasks - 1 else n tasks.append(asyncio.create_task(calculate_partial_sum(start, end))) results = await asyncio.gather(*tasks) total_sum = sum(results) return total_sum start_time = time.time() sum_result = asyncio.run(calculate_sum()) end_time = time.time() print(f\"Async sum: {sum_result}, Time taken: {end_time - start_time} seconds\")","title":"Async"},{"location":"lab_2/#2_1","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"lab_2/#async_1","text":"import os import aiohttp import asyncio import asyncpg from bs4 import BeautifulSoup import time from ex_2.urls import urls from dotenv import load_dotenv load_dotenv() async def save_to_db(data): conn = await asyncpg.connect(os.getenv(\"DB_URL\")) try: await conn.execute( \"INSERT INTO parce (url, title, process_type) VALUES ($1, $2, $3)\", data['url'], data['title'], 'async' ) finally: await conn.close() async def parse_and_save(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') title = soup.find('title').text await save_to_db({'url': url, 'title': title}) async def main(urls): tasks = [] for url in urls: task = asyncio.create_task(parse_and_save(url)) tasks.append(task) await asyncio.gather(*tasks) if __name__ == \"__main__\": start_time = time.time() asyncio.run(main(urls)) end_time = time.time() execution_time = end_time - start_time with open('../times.txt', 'a') as f: f.write(f\"Async: {execution_time}\\n\")","title":"Async"},{"location":"lab_2/#thread_1","text":"from threading import Thread import requests from bs4 import BeautifulSoup import time from ex_2.urls import urls from ex_2.db import save_to_database from dotenv import load_dotenv load_dotenv() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title, 'threading') def main(urls): threads = [] for url in urls: thread = Thread(target=parse_and_save, args=(url,)) threads.append(thread) thread.start() for thread in threads: thread.join() if __name__ == \"__main__\": start_time = time.time() main(urls) end_time = time.time() execution_time = end_time - start_time with open('../times.txt', 'a') as f: f.write(f\"Tread: {execution_time}\\n\")","title":"Thread"},{"location":"lab_2/#multiprocess_1","text":"from multiprocessing import Pool import requests from bs4 import BeautifulSoup import time from ex_2.urls import urls from ex_2.db import save_to_database from dotenv import load_dotenv load_dotenv() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title, 'mltprcs') def main(urls): num_process = len(urls) if len(urls) < 4 else 4 pool = Pool(processes=num_process) pool.map(parse_and_save, urls) if __name__ == \"__main__\": start_time = time.time() main(urls) end_time = time.time() execution_time = end_time - start_time with open('../times.txt', 'a') as f: f.write(f\"Multiprocess: {execution_time}\\n\")","title":"Multiprocess"},{"location":"lab_2/#database-save-for-threading-and-myltiprocess","text":"import psycopg2 import os from dotenv import load_dotenv load_dotenv() def save_to_database(url, title, method): conn = psycopg2.connect(os.getenv(\"DB_URL\")) curs = conn.cursor() curs.execute(\"INSERT INTO parce (url, title, process_type) VALUES (%s, %s, %s)\", (url, title, method)) conn.commit() curs.close() conn.close()","title":"Database save (for threading and myltiprocess)"},{"location":"lab_2/#_1","text":"| Solution | Time (seconds) | |---------------|--------------------| | Async | 1.2993099689483643 | | Multiprocess | 1.6727426052093506 | | Threading | 1.244816780090332 |","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b"},{"location":"lab_3/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f 3 \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 project/ \u2502 \u251c\u2500\u2500 taskmanager/ (\u043f\u0435\u0440\u0432\u0430\u044f \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f) \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 endpoints/ (\u043f\u0430\u0440\u0441\u0435\u0440 \u0438\u0437 \u0432\u0442\u043e\u0440\u043e\u0439 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439) \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 docker-compose.yaml \u2514\u2500\u2500 .env docker docker-compose version: '3.10' services: taskmanager: container_name: taskmanager build: context: ./taskmanager env_file: .env depends_on: - db ports: - \"8000:8000\" command: uvicorn main:app --host 0.0.0.0 --port 8000 networks: - backend_3 restart: always celery_app: container_name: celery_app build: context: ./celery_app env_file: .env restart: always ports: - \"8002:8002\" command: uvicorn main:app --host 0.0.0.0 --port 8002 depends_on: - redis - db networks: - backend_3 celery_start: build: context: ./celery_app container_name: celery_start command: celery -A celery_start worker --loglevel=info restart: always depends_on: - redis - celery_app - db networks: - backend_3 redis: image: redis ports: - \"6379:6379\" networks: - backend_3 depends_on: - db db: image: postgres restart: always environment: - POSTGRES_PASSWORD=postgres - POSTGRES_USER=postgres - POSTGRES_DB=web_data volumes: - postgres_data:/var/lib/postgresql/data/ ports: - \"5432:5432\" networks: - backend_3 volumes: postgres_data: networks: backend_3: driver: bridge Dockerfile (taskamanger) FROM python:3.10-alpine3.19 WORKDIR /taskmanager COPY . . RUN pip3 install -r requirements.txt CMD uvicorn main:app --host localhost --port 8000 Dockerfile (celery_app) FROM python:3.10-alpine3.19 WORKDIR /taskmanager COPY . . RUN pip3 install -r requirements.txt CMD uvicorn main:app --host localhost --port 8002 \u0421elery celery_app = Celery( \"worker\", broker=\"redis://redis:6379/0\", backend=\"redis://redis:6379/0\", ) celery_app.conf.update( task_routes={ \"parse.parse_and_save\": \"main-queue\", }, ) \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0442\u0430\u0441\u043a\u0438 import requests from bs4 import BeautifulSoup from models import Parce from celery_main import celery_app @celery_app.task def parse_and_save(url, session): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No title' new_article = Parce( url = url, article_title = title ) session.add(new_article) session.commit()","title":"Lab3"},{"location":"lab_3/#3","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f 3"},{"location":"lab_3/#_1","text":"project/ \u2502 \u251c\u2500\u2500 taskmanager/ (\u043f\u0435\u0440\u0432\u0430\u044f \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f) \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 endpoints/ (\u043f\u0430\u0440\u0441\u0435\u0440 \u0438\u0437 \u0432\u0442\u043e\u0440\u043e\u0439 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439) \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 docker-compose.yaml \u2514\u2500\u2500 .env","title":"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430"},{"location":"lab_3/#docker","text":"","title":"docker"},{"location":"lab_3/#docker-compose","text":"version: '3.10' services: taskmanager: container_name: taskmanager build: context: ./taskmanager env_file: .env depends_on: - db ports: - \"8000:8000\" command: uvicorn main:app --host 0.0.0.0 --port 8000 networks: - backend_3 restart: always celery_app: container_name: celery_app build: context: ./celery_app env_file: .env restart: always ports: - \"8002:8002\" command: uvicorn main:app --host 0.0.0.0 --port 8002 depends_on: - redis - db networks: - backend_3 celery_start: build: context: ./celery_app container_name: celery_start command: celery -A celery_start worker --loglevel=info restart: always depends_on: - redis - celery_app - db networks: - backend_3 redis: image: redis ports: - \"6379:6379\" networks: - backend_3 depends_on: - db db: image: postgres restart: always environment: - POSTGRES_PASSWORD=postgres - POSTGRES_USER=postgres - POSTGRES_DB=web_data volumes: - postgres_data:/var/lib/postgresql/data/ ports: - \"5432:5432\" networks: - backend_3 volumes: postgres_data: networks: backend_3: driver: bridge","title":"docker-compose"},{"location":"lab_3/#dockerfile-taskamanger","text":"FROM python:3.10-alpine3.19 WORKDIR /taskmanager COPY . . RUN pip3 install -r requirements.txt CMD uvicorn main:app --host localhost --port 8000","title":"Dockerfile (taskamanger)"},{"location":"lab_3/#dockerfile-celery_app","text":"FROM python:3.10-alpine3.19 WORKDIR /taskmanager COPY . . RUN pip3 install -r requirements.txt CMD uvicorn main:app --host localhost --port 8002","title":"Dockerfile (celery_app)"},{"location":"lab_3/#elery","text":"celery_app = Celery( \"worker\", broker=\"redis://redis:6379/0\", backend=\"redis://redis:6379/0\", ) celery_app.conf.update( task_routes={ \"parse.parse_and_save\": \"main-queue\", }, )","title":"\u0421elery"},{"location":"lab_3/#_2","text":"import requests from bs4 import BeautifulSoup from models import Parce from celery_main import celery_app @celery_app.task def parse_and_save(url, session): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No title' new_article = Parce( url = url, article_title = title ) session.add(new_article) session.commit()","title":"\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0442\u0430\u0441\u043a\u0438"}]}